# -*- coding: utf-8 -*-
"""Ejercicio1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sHmPsZpBC-MC68r9gc7zvKwmODh0GwTX
"""

#           Autor:
#   David Osvaldo Chay May
#   may876518@gmail.com
#   Version 1.0 : 11/02/2025
#
import numpy as np  #Se importa la libreria numpy para hacer calculos numericos
import matplotlib.pyplot as plt  # Se importa matplotlib para graficar.

# Definir la función que queremos encontrar la raíz.
def f(x):
    return x**3 - 4*x - 9  # Es una función cúbica, queremos encontrar un valor de x donde f(x) = 0.

# Algoritmo del Método de Bisección
def biseccion(a, b, tol=1e-3, max_iter=100): #Validamos que el metodo de bisección sea aplicable
    if f(a) * f(b) >= 0:  # La función debe cambiar de signo en el intervalo (f(a) * f(b) < 0)
        print("El método de bisección no es aplicable en el intervalo dado.")
        return None

    # Listas para almacenar los valores de cada iteración
    iteraciones = []
    errores_abs = []  # Se guarda el erro absoluto
    errores_rel = []  #Se guarda el error relativo
    errores_cuad = []  # Se guarda el error cuadrático
    c_old = a  # Inicializamos c_old con el valor de a para calcular errores en la primera iteración

    # Mostramos el encabezado de la tabla
    print("\nIteraciones del Método de Bisección:")
    print("Iter |       a       |       b       |       c       |      f(c)      |     Error Abs     |   Error Rel   |  Error Cuadrático  ")
    print("-" * 110)

    # Iteramos hasta el máximo de iteraciones o hasta que se cumpla la tolerancia
    for i in range(max_iter):
        c = (a + b) / 2 #Se calcula el punto medio del intervalo
        iteraciones.append(c)  # Se guarda la iteración

        # Calculamos los errores
        error_abs = abs(c - c_old)  # Error absoluto
        error_rel = abs((c - c_old) / c) if c != 0 else 0  # Error relativo (evitamos división por 0)
        error_cuad = error_abs**2  # Error cuadrático
        errores_abs.append(error_abs)
        errores_rel.append(error_rel)
        errores_cuad.append(error_cuad)

        # Imprimimos la iteración actual con los valores calculados
        print(f"{i+1:4d} | {a:.8f} | {b:.8f} | {c:.8f} | {f(c):.8f} | {error_abs:.8e} | {error_rel:.8e} | {error_cuad:.8e}")

        # Condición de parada: si f(c) es suficientemente pequeño o el error absoluto es menor que la tolerancia
        if abs(f(c)) < tol or error_abs < tol:
            break

        # Decidimos en qué subintervalo continuar
        if f(a) * f(c) < 0:
            b = c  # La raíz está en el intervalo [a, c]
        else:
            a = c  # La raíz está en el intervalo [c, b]

        c_old = c  # Guardamos el valor de c para calcular errores en la siguiente iteración

    return iteraciones, errores_abs, errores_rel, errores_cuad  # Retornamos los valores obtenidos

# Parámetros iniciales del intervalo donde buscamos la raíz
a, b = 2, 3
iteraciones, errores_abs, errores_rel, errores_cuad = biseccion(a, b)

# Graficamos la convergencia del método de bisección
x = np.linspace(a - 1, b + 1, 400)  # Creamos valores de x para la gráfica
y = f(x)  # Evaluamos f(x) para cada x
fig, ax1 = plt.subplots(figsize=(8, 6))  # Creamos la figura y los ejes
ax1.plot(x, y, label=r'$f(x) = x^3 - 4x - 9$', color='b')  # Se graficamos la función
ax1.axhline(0, color='k', linestyle='--', linewidth=1)  # Línea horizontal en y=0 para referencia
ax1.scatter(iteraciones, [f(c) for c in iteraciones], color='red', label='Iteraciones')  # Marcamos las iteraciones en la gráfica
ax1.set_xlabel('x')  # Etiqueta del eje x
ax1.set_ylabel('f(x)')  # Etiqueta del eje y
ax1.set_title("Convergencia del Método de Bisección")  # Título del gráfico
ax1.legend()
ax1.grid()  # Activamos la cuadrícula
plt.savefig("convergencia_biseccion.png", dpi=300)  # Guardamos la imagen en un archivo
plt.show()  # Mostramos la gráfica

# Graficamos los errores (absoluto, relativo y cuadrático)
fig, ax2 = plt.subplots(figsize=(8, 6))  # Creamos la figura
ax2.plot(range(1, len(errores_abs)+1), errores_abs, marker='o', linestyle='-', color='r', label="Error Absoluto")  # Graficamos error absoluto
ax2.plot(range(1, len(errores_rel)+1), errores_rel, marker='s', linestyle='-', color='g', label="Error Relativo")  # Graficamos error relativo
ax2.plot(range(1, len(errores_cuad)+1), errores_cuad, marker='^', linestyle='-', color='b', label="Error Cuadrático")  # Graficamos error cuadrático
ax2.set_yscale("log")  # Usamos escala logarítmica para visualizar mejor los errores
ax2.set_xlabel("Iteración")  # Etiqueta del eje x
ax2.set_ylabel("Error")  # Etiqueta del eje y
ax2.set_title("Errores Absoluto, Relativo y Cuadrático en cada Iteración")  # Título de la gráfica
ax2.legend()  # Mostramos la leyenda
ax2.grid()  # Activamos la cuadrícula
plt.savefig("errores_biseccion.png", dpi=300)  # Guardamos la imagen de los errores
plt.show()  # Mostramos la gráfica
