# -*- coding: utf-8 -*-
"""Ejercicio1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sHmPsZpBC-MC68r9gc7zvKwmODh0GwTX
"""

#           Autor:
#   David Osvaldo Chay May
#   may876518@gmail.com
#   Versión 1.0 : 13/02/2025



import numpy as np  # Importamos la librería NumPy para manejar cálculos numéricos
import matplotlib.pyplot as plt  # Importamos Matplotlib para graficar

# Definir la función cuya raíz queremos encontrar
def f(x):
    return x**3 - 4*x - 9  # Función f(x) = x³ - 4x - 9

# Implementación del Método de Bisección
def biseccion(a, b, tol=1e-5, max_iter=100):
    # Verificamos que haya un cambio de signo en el intervalo [a, b]
    if f(a) * f(b) >= 0:
        print("El método de bisección no es aplicable en el intervalo dado.")
        return None  # Retorna None si el método no se puede aplicar

    # Listas para almacenar las iteraciones y los errores
    iteraciones = []
    errores_abs = []  # Error absoluto
    errores_rel = []  # Error relativo
    errores_cua = []  # Error cuadrático

    c_old = a  # Valor previo de c para calcular errores

    # Encabezado para mostrar las iteraciones en la consola
    print("\nIteraciones del Método de Bisección:")
    print("Iter |       a       |       b       |       c       |      f(c)      |     Error Absoluto  | Error Relativo  | Error Cuadrático    ")
    print("-" * 85)

    # Iteramos hasta el número máximo de iteraciones
    for i in range(max_iter):
        c = (a + b) / 2  # Punto medio del intervalo
        iteraciones.append(c)  # Guardamos la iteración actual

        # Cálculo de errores
        error_abs = abs(c - c_old)  # Error absoluto
        error_rel = error_abs / c  # Error relativo
        error_cua = error_abs**2  # Error cuadrático
        errores_abs.append(error_abs)
        errores_rel.append(error_rel)
        errores_cua.append(error_cua)

        # Imprimimos los valores de la iteración actual
        print(f"{i+1:4d} | {a:.8f} | {b:.8f} | {c:.8f} | {f(c):.8f} | {error_abs:.8e} | {error_rel:.8e} | {error_cua:.8e}")

        # Verificamos si el método ha convergido (f(c) cercano a 0 o error absoluto menor que la tolerancia)
        if abs(f(c)) < tol or error_abs < tol:
            break  # Terminamos la iteración

        # Determinamos el nuevo intervalo [a, b] basado en el signo de f(c)
        if f(a) * f(c) < 0:
            b = c  # La raíz está en el intervalo [a, c]
        else:
            a = c  # La raíz está en el intervalo [c, b]

        c_old = c  # Actualizamos el valor de c para el siguiente cálculo de error

    return iteraciones, errores_abs, errores_rel, errores_cua  # Retornamos los valores obtenidos

# Parámetros iniciales del intervalo
a, b = 2, 3  # Definimos el intervalo donde buscamos la raíz

# Llamamos al método de bisección
iteraciones, errores_abs, errores_rel, errores_cua = biseccion(a, b)

# Crear la figura para graficar
fig, ax = plt.subplots(1, 2, figsize=(14, 5))

# Definir los valores para graficar la función
x = np.linspace(a - 1, b + 1, 400)  # Valores entre a-1 y b+1 con 400 puntos
y = f(x)  # Evaluamos la función en los puntos x

# Gráfica de la función y la convergencia de iteraciones
ax[0].plot(x, y, label=r'$f(x) =x^3-4x-9$', color='b')  # Graficamos f(x)
ax[0].axhline(0, color='k', linestyle='--', linewidth=1)  # Línea horizontal en y=0
ax[0].scatter(iteraciones, [f(c) for c in iteraciones], color='red', label='Iteraciones')  # Puntos de iteraciones en rojo
ax[0].set_xlabel('x')  # Etiqueta del eje x
ax[0].set_ylabel('f(x)')  # Etiqueta del eje y
ax[0].set_title("Convergencia del Método de Bisección")  # Título de la gráfica
ax[0].legend()  # Agregamos la leyenda
ax[0].grid()  # Mostramos la cuadrícula

# Gráfica de convergencia del error
ax[1].plot(range(1, len(errores_abs)+1), errores_abs, marker='o', linestyle='-', label="Error Absoluto", color='r')  # Error absoluto
ax[1].plot(range(1, len(errores_rel)+1), errores_rel, marker='s', linestyle='-', label="Error Relativo", color='b')  # Error relativo
ax[1].plot(range(1, len(errores_cua)+1), errores_cua, marker='^', linestyle='-', label="Error Cuadrático", color='g')  # Error cuadrático
ax[1].set_yscale("log")  # Usamos escala logarítmica para visualizar los errores mejor
ax[1].set_xlabel("Iteración")  # Etiqueta del eje x
ax[1].set_ylabel("Error")  # Etiqueta del eje y
ax[1].set_title("Evolución del Error en cada Iteración")  # Título de la gráfica
ax[1].grid()  # Mostramos la cuadrícula
ax[1].legend()  # Agregamos la leyenda

# Guardamos la figura generada en un archivo
plt.savefig("biseccion_convergencia.png", dpi=300)  # Guardamos la imagen en formato PNG con resolución 300 dpi
plt.show()  # Mostramos la gráfica
