# -*- coding: utf-8 -*-
"""Ejercicio3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QP43KO6kBR3xca7G7eyrMeb1YiPKMkPD
"""

#           Autor:
#   David Osvaldo Chay May
#   may876518@gmail.com
#   Versión 1.0 : 13/02/2025

#Se importa la libreria numpy para realizar operaciones matemáticas y matplolib para hacer graficas
import numpy as np
import matplotlib.pyplot as plt

# Definir la función f(x) que se usará en el método de bisección
def f(x):
    return np.cos(x)-x  # La función f(x) es coseno de x menos x

# Algoritmo numérico del Método de Bisección
def biseccion(a, b, tol=1e-5, max_iter=100):
    # Verificar si el producto de f(a) y f(b) es mayor o igual a 0. Si es así, el método no es aplicable
    if f(a) * f(b) >= 0:
        print("El método de bisección no es aplicable en el intervalo dado.")
        return None

    # Listas para almacenar los resultados de cada iteración
    iteraciones = []
    errores_abs = []
    errores_rel = []
    errores_cua = []

    c_old = a  # Almacenar el valor de 'a' como c_old para calcular los errores

    # Imprimir los encabezados de la tabla de resultados
    print("\nIteraciones del Método de Bisección:")
    print("Iter |       a       |       b       |       c       |      f(c)      |     Error Absoluto  | Error Relativo  | Error Cuadrático    ")
    print("-" * 85)

    # Comenzar el proceso de iteración hasta el máximo de iteraciones permitido
    for i in range(max_iter):
        # Calcular el punto medio 'c' entre a y b
        c = (a + b) / 2
        iteraciones.append(c)  # Guardar el valor de 'c' en la lista de iteraciones

        # Calcular los errores absoluto, relativo y cuadrático
        error_abs = abs(c - c_old)  # Error absoluto
        error_rel = error_abs / c  # Error relativo
        error_cua = error_abs**2   # Error cuadrático
        errores_abs.append(error_abs)  # Guardar el error absoluto en la lista
        errores_rel.append(error_rel)  # Guardar el error relativo en la lista
        errores_cua.append(error_cua)  # Guardar el error cuadrático en la lista

        # Imprimir los resultados de la iteración
        print(f"{i+1:4d} | {a:.8f} | {b:.8f} | {c:.8f} | {f(c):.8f} | {error_abs:.8e} | {error_rel:.8e} | {error_cua:.8e}")

        # Si el valor de f(c) es menor que la tolerancia o el error absoluto es menor que la tolerancia, se termina el proceso
        if abs(f(c)) < tol or error_abs < tol:
            break

        # Si f(a) * f(c) < 0, se ajusta el intervalo cambiando 'b', de lo contrario se ajusta cambiando 'a'
        if f(a) * f(c) < 0:
            b = c
        else:
            a = c

        # Actualizar el valor de 'c_old' para el cálculo del error en la próxima iteración
        c_old = c

    # Devolver los resultados: iteraciones, errores absolutos, relativos y cuadrados
    return iteraciones, errores_abs, errores_rel, errores_cua

# Parámetros iniciales para el intervalo [a, b]
#a, b = 2, 3  # Opción 1: intervalo [2, 3]
a, b = 0, 1.5  # Opción 2: intervalo [0, 1.5]
#a, b = 0, 1  # Intervalo [0, 1] en este caso

# Llamar a la función de bisección para obtener los resultados
iteraciones, errores_abs, errores_rel, errores_cua = biseccion(a, b)

# Crear una figura y un conjunto de ejes (subgráficos) para mostrar las gráficas
fig, ax = plt.subplots(1, 2, figsize=(14, 5))

# Gráfica de la función y la convergencia de las iteraciones
x = np.linspace(a - 1, b + 1, 400)  # Crear un rango de valores de x para graficar
y = f(x)  # Evaluar la función f(x) para esos valores de x

# Graficar la función f(x) y las iteraciones
ax[0].plot(x, y, label=r'$f(x) =cos(x)-x$', color='b')  # Graficar f(x)
ax[0].axhline(0, color='k', linestyle='--', linewidth=1)  # Línea horizontal en y=0 (para referencia)
ax[0].scatter(iteraciones, [f(c) for c in iteraciones], color='red', label='Iteraciones')  # Graficar las iteraciones en rojo
ax[0].set_xlabel('x')  # Etiqueta del eje x
ax[0].set_ylabel('f(x)')  # Etiqueta del eje y
ax[0].set_title("Convergencia del Método de Bisección")  # Título de la gráfica
ax[0].legend()  # Para agregar la leyenda
ax[0].grid()  # Activar la cuadrícula

# Gráfica de la convergencia del error
ax[1].plot(range(1, len(errores_abs)+1), errores_abs, marker='o', linestyle='-', label="Error Absoluto", color='r')  # Error absoluto en rojo
ax[1].plot(range(1, len(errores_rel)+1), errores_rel, marker='s', linestyle='-', label="Error Relativo", color='b')  # Error relativo en azul
ax[1].plot(range(1, len(errores_cua)+1), errores_cua, marker='^', linestyle='-', label="Error Cuadrático", color='g')  # Error cuadrático en verde
ax[1].set_yscale("log")  # Usar escala logarítmica para el eje y
ax[1].set_xlabel("Iteración")  # Etiqueta del eje x
ax[1].set_ylabel("Error")  # Etiqueta del eje y
ax[1].set_title("En cada Iteración")  # Título de la gráfica
ax[1].grid()  # Activar la cuadrícula

ax[1].legend()  # Se agrega la leyenda

# Guardar la figura generada como un archivo de imagen
plt.savefig("biseccion_convergencia.png", dpi=300)  # Guardar con alta resolución
plt.show()  # Mostrar las gráficas